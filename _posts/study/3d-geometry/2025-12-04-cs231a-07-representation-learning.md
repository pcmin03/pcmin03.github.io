---
title: "[CS231A] Lecture 07: Representation Learning (표현 학습)"
categories: [3D Geometry]
tags: [3D Vision, CS231A, Representation Learning, Computer Vision]
article_header:
  type: overlay
  theme: dark
  background_color: '#0d1b2a'
  background_image:
    gradient: 'linear-gradient(135deg, rgba(13, 27, 42, .85), rgba(176, 125, 103, .65))'
    src: /assets/images/study/3d-geometry.jpg
mathjax: true
mathjax_autoNumber: true
---

**Stanford CS231A: Computer Vision, From 3D Reconstruction to Recognition**

이 포스트는 Stanford CS231A 강의의 일곱 번째 강의 노트인 "Representations and Representation Learning"를 정리한 것입니다.

**원본 강의 노트**: [07-representation-learning.pdf](https://web.stanford.edu/class/cs231a/course_notes/07-representation-learning.pdf)

<!--more-->

## 1. Overview

### 1.1 States and Representations

동적 시스템의 **state(상태)**는 기본적으로 압축된 설명이며 이 시스템의 핵심 측면을 포착합니다. 이러한 측면은 시간에 따라 변하거나 고정된 파라미터일 수 있습니다. Figure 1에 표시된 시스템을 고려하세요: 수직 평면을 따라 이동하는 보행 로봇입니다. 이 예에서 시간에 따라 변하는 양은 공간에서 로봇의 현재 포즈(위치 및 방향), 관절 구성 및 속도에 대한 정보로 구성될 수 있습니다. 고정된 파라미터는 로봇의 팔다리 길이, 각 팔다리의 무게 또는 관절 마찰일 수 있습니다. 시스템 상태에 대한 수많은 표현이 가능합니다. 예를 들어, 관절 각도, 속도, 위치 또는 로봇의 포즈의 선택을 사용할 수 있습니다. 또한 이러한 양은 다른 방식으로 표현될 수 있습니다. 예를 들어, 로봇 몸체의 방향은 오일러 각, 각도-축 표현 또는 쿼터니언으로 제공될 수 있습니다. 위치는 공간 좌표 또는 극좌표로 제공될 수 있습니다. 어떤 표현을 선택하는지는 종종 작업에 따라 다릅니다. 마지막으로, 상태 표현도 학습될 수 있으며 나중에 다시 돌아오겠습니다.

동적 시스템의 상태는 정적이지 않고 시간에 따라 진화합니다. 보행자의 예에서, 그 포즈와 관절 구성은 시간에 따라 변합니다. 시간 $t$에서의 상태를 $x_t$로 표시합니다. 이러한 동적 시스템에 대한 일반적인 가정은 **Markov property(마르코프 속성)**를 가진다는 것입니다: 미래 상태는 현재 상태에만 의존하고 과거 상태에는 의존하지 않습니다. 다시 말해, 상태 $x_{t+1}$은 현재 상태 $x_t$가 주어지면 과거 상태 $x_1, x_2, \ldots, x_{t-1}$에 대해 조건부 독립입니다:

$$P(x_{t+1} | x_t, x_{t-1}, \ldots, x_2, x_1) = P(x_{t+1} | x_t) \tag{1}$$

마르코프 속성은 미래 상태를 예측할 때 의미가 있습니다. 이 속성이 유지되면, 미래 상태는 현재에만 의존합니다 - 과거에 의존하지 않습니다. 따라서 시스템의 특정 역학에 따라 현재 상태가 주어지면 다음 타임스탬프에서의 상태를 예측할 수 있습니다: $f(x_t) = x_{t+1}$. 예를 들어, 상태에 관절의 현재 각속도가 포함되어 있으면 다음 시간 단계에서 관절 각도를 예측할 수 있습니다. $f(\cdot)$는 비선형 함수일 수 있으며, 단순화를 위해 역학이 시간에 걸쳐 일정하다고 종종 가정합니다. 우리는 이러한 시스템을 **Markov chains(마르코프 체인)**로 모델링합니다. Figure 2는 마르코프 체인의 조건부 의존성 구조를 노드가 랜덤 변수이고 엣지가 조건부 의존성을 나타내는 확률 그래픽 모델로 시각화합니다.

마르코프 체인은 동적 시스템을 완전히 관찰 가능한 것으로 모델링합니다. 즉, 상태가 알려져 있습니다. 실제로 시간 $t$에서 시스템의 상태는 직접 관찰할 수 없기 때문에 종종 알려지지 않습니다. 우리의 작업은 노이즈 센서 관측으로부터 실제 상태를 추정하는 것입니다: **state estimation(상태 추정)**이라고 불리는 프로세스입니다. 이러한 시스템은 부분적으로 관찰 가능하며 상태가 "숨겨져" 있기 때문에 **hidden Markov models(HMM, 은닉 마르코프 모델)**로 모델링할 수 있습니다. 우리는 상태 $x_t$가 마르코프 프로세스로 동작한다고 가정합니다. 또한 시간 $t$에서의 관측 $z_t$는 그 시간의 상태 $x_t$에만 의존한다고 가정합니다. 다시 말해, 관측 $z_t$는 $x_t$가 주어지면 모든 이전 상태와 관측에 대해 조건부 독립입니다:

$$P(z_t | x_t, x_{t-1}, \ldots, x_2, x_1) = P(z_t | x_t) \tag{2}$$

이것은 현재 관측 $z_t$를 예측하는 관측 모델 $h(\cdot)$가 $x_t$에만 의존한다는 것을 의미합니다: $h(x_t) = z_t$. 비전 예제로 이것을 구체화하겠습니다. Figure 4에 표시된 시점을 가진 자율 주행 자동차라면, 모든 교통 참가자의 상태를 알고 싶을 것입니다: 3D 위치, 바운딩 박스(크기), 가능하면 모든 사람의 속도입니다. 그러나 이 정보는 직접 제공되지 않으며 예를 들어 스테레오 이미지 쌍, RGB 프레임 또는 LIDAR 데이터를 통해 캡처된 센서 관측으로부터 추정되어야 합니다.

최적 추정에 대한 향후 강의에서, 이러한 마르코프 프로세스에서 상태가 어떻게 진화하는지에 영향을 미치는 로봇 동작 또는 제어 입력을 고려할 것입니다. 구체적으로, $f(x_t) = x_{t+1}$ 대신 $f(x_t, u_t) = x_{t+1}$을 가질 것입니다. 여기서 $u_t$는 시간 $t$에 로봇이 취한 제어 입력 또는 동작입니다. 이것들은 Figure 1의 보행자의 다리를 움직이는 관절 모터로 전송되는 토크 명령이거나 자동차의 경우 조향 및 스로틀일 수 있습니다. 흥미로운 문제는 다음 최선의 동작 $u_t$를 어떻게 결정할지입니다. 이것을 **decision making(의사 결정)**이라고 합니다. 마르코프 체인은 **Markov decision processes(MDP, 마르코프 의사 결정 프로세스)**로 일반화되고, 은닉 마르코프 모델은 의사 결정을 공식화하는 데 사용되는 **partially observable Markov decision processes(POMDP, 부분 관찰 가능 마르코프 의사 결정 프로세스)**로 일반화됩니다.

### 1.2 Generative and Discriminative Approaches

관측으로부터 상태를 어떻게 추정할 수 있을까요? 입력 RGB 이미지(관측 $z$)로부터 객체의 포즈(상태 $x$)를 추정하는 작업을 고려하겠습니다. 6D 포즈는 객체의 3D 평행 이동과 3D 회전을 모두 나타냅니다(총 6개의 파라미터).

우리는 두 가지 접근 방식을 높은 수준에서 설명하고 나중에 수업에서 구체적인 내용을 다룰 것입니다. 첫째, **generative model(생성 모델)**은 관측 $z$와 상태 $x$가 주어졌을 때 결합 확률 분포 $p(z, x)$를 설명합니다. 우리는 likelihood $p(z|x)$(방정식 2 참조)와 prior $p(x)$를 사용하여 베이즈 규칙으로 이 결합 분포를 계산합니다. 객체 포즈 추정의 예에서, 객체 포즈 $x^{(i)}$를 $p(x)$에서 샘플링할 수 있습니다. 이 prior는 공간에서의 균일 분포만큼 간단하거나 이 객체의 가능한 위치를 포착하는 더 복잡한 것일 수 있습니다(예: 건물 옆이 아닌 도로의 자동차). 이 포즈 샘플이 주어지면, 관측 모델을 사용하여 가장 가능성 높은 관측 $h(x^{(i)}) = z^{(i)}$를 생성할 수 있습니다. 즉, 샘플링된 포즈에서 이미지 평면으로의 객체의 2D 투영입니다. $p(z|x^{(i)})$는 가설 포즈 $x^{(i)}$가 주어졌을 때 실제 관측 $z$의 likelihood를 $z^{(i)}$와 $z$ 사이의 차이를 비교하여 제공합니다.

둘째, **discriminative model(판별 모델)**은 관측 $z$가 주어졌을 때 상태 $x$의 조건부 확률 $p(x|z)$를 설명합니다. 예를 들어, Figure 5의 PoseCNN과 같은 신경망을 훈련시켜 입력 이미지 $z$를 가장 가능성 높은 출력 포즈 $x$로 직접 매핑할 수 있습니다. 판별 모델과 생성 모델의 차이에 대해 더 자세히 알아보려면 https://cs229.stanford.edu/notes-spring2019/cs229-notes2.pdf의 CS229 노트를 참조하세요.

## 2. Representation Learning

### 2.1 Representations in Computer Vision

우리는 컴퓨터 비전에서 "representations(표현)"이라는 용어가 어떻게 사용되는지에 대한 주의를 돌립니다. Figure 6의 높은 수준의 의미론적 분할 파이프라인을 고려하세요. 그것은 그 파이프라인 내의 어떤 단계에서도 데이터가 특정 표현으로 제공된다는 것을 설명합니다. 따라서 용어 표현을 더 명확하게 자격을 갖추기 위해 맥락을 도입하겠습니다.

파이프라인의 한쪽 끝에는 어떤 센서에 의해 캡처된 원시 센서 데이터가 있습니다. **input representation(입력 표현)**은 원시 센서 데이터 형식을 설명합니다. Figure 6에서 우리의 입력은 물고기를 포함하는 바다 내의 3D 장면의 관측입니다. 센서 선택에 따라 원시 센서 데이터는 2D 이미지, 깊이 이미지 또는 포인트 클라우드로 표현될 수 있습니다. 특정 형식 내에서도 입력 표현에 미묘한 차이가 있습니다. 예를 들어, 컬러 대 그레이스케일, 스테레오 대 단안, RGB 대 HSV 이미지 색 공간입니다. 파이프라인의 다른 끝에서, 원시 센서 데이터로부터 추론되는 정보는 고려된 의사 결정 작업에 필요한 장면의 높은 수준의 핵심 측면을 간결하게 설명하는 **output representation(출력 표현)**으로 제공됩니다. 우리가 생물학자이고 목표가 우리가 만나는 물고기의 수를 세는 것이라면, 관련 출력 표현은 출력 쪽의 "Fish" 레이블이거나 물고기의 종을 나타내는 더 구체적인 레이블일 수 있습니다. 그러나 산호초를 탐색하려는 드론이라면, 물고기의 6D 포즈와 3D 바운딩 박스를 추정하는 것에 더 관심이 있을 수 있으며, 이것은 궤적 계획에 통합하는 데 유용할 것입니다. 입력과 출력 표현 사이에는 어떤 **intermediate representation(중간 표현)**의 입력 데이터가 있습니다. 이 표현은 일반적으로 고차원 입력 감각 데이터를 요약하는 압축된 저차원 벡터입니다. 중간 표현은 입력 표현에서 제공된 입력 데이터를 압축합니다. 중간 표현에서 제공된 데이터는 그런 다음 출력 표현에서 관련 양을 유도하는 데 사용됩니다.

이 시점에서 자연스러운 질문들은 다음과 같습니다:

1. 표현이 의사 결정에 매우 중요하기 때문에, 좋은 표현을 만드는 것은 무엇일까요? Bengio et al [1]은 좋은 표현에 대한 다음 요구 사항을 제안했습니다:
   - 표현은 **compact(압축적)**이어야 합니다. 즉, 최소이지만
   - **explanatory(설명적)**이어야 합니다. 즉, 많은 수의 가능한 입력 구성을 표현하고 포착할 수 있을 만큼 충분히 표현력이 있어야 합니다.
   - 표현은 **disentangled(분리된)**이어야 합니다. 즉, 입력 데이터 변형의 다른 설명 요인은 이러한 요인이 서로 독립적으로 변경될 수 있다는 것을 반영하기 위해 독립적으로 표현되어야 합니다.
   - 표현은 또한 **hierarchical(계층적)**이어야 하므로 더 추상적인 개념이 덜 추상적인 것으로 설명될 수 있어 기능 재사용을 허용하고 계산 효율성을 증가시킵니다.
   - 궁극적으로, 이 표현은 다운스트림 추론, 예측 또는 의사 결정 문제를 더 쉽게 만들어야 합니다. 따라서 표현의 품질은 다운스트림 성능으로도 정량화될 수 있습니다.

2. 실제로 중간 및 출력 표현을 어떻게 얻을까요? 이것은 다음 섹션에서 논의될 것입니다.

### 2.2 Traditional CV and Interpretable Representations

전통적인($\approx$ 2012 이전) 컴퓨터 비전 파이프라인의 높은 수준의 시각화가 Figure 7에 표시되어 있습니다. 입력 데이터는 특정 입력 표현으로 제공된 입력에서 추출된 수작업 특징의 조합으로 구성된 중간 표현으로 압축됩니다. 특징(descriptors)의 특정 선택은 유연하며 작업별로 만들 수 있습니다. 예를 들어, 물고기 몸체의 특정 줄무늬나 디자인이 다른 종류의 물고기나 바다의 것들과 구별할 수 있다고 믿는다면, 가장자리와 색상을 추출하여 원시 입력 데이터의 중간 표현을 형성할 수 있습니다. Figure 7에 표시된 예에서, 출력의 표현은 클래스 레이블입니다. 이 클래스 레이블을 추론하기 위해, 중간 표현은 학습되거나 더 수동으로 정의된 휴리스틱을 기반으로 하는 분류기에 공급됩니다. 간단한 예로, 이미지의 색상 히스토그램에 오렌지와 흰색이 많이 포함되어 있으면 이미지에 클라운피시가 포함될 가능성이 높다고 말할 수 있는 휴리스틱을 정의할 수 있습니다. 많은 고전 문헌이 종종 이미지 처리 및 필터링 방법을 기반으로 하는 새로운 특징 추출기를 개발하는 데 초점을 맞췄습니다. 특정 방법은 이 수업의 범위를 벗어나지만, 이 문서 끝에 추가 읽기를 위한 여러 참고 자료를 제공합니다. 고전적인 특징 추출 방법의 주요 이점은 **interpretable representations(해석 가능한 표현)**을 생성한다는 것입니다: 우리가 이 방법들을 수작업으로 설계했기 때문에 특정 출력 표현이 선택된 이유를 쉽게 설명할 수 있습니다. 이것은 법률 또는 의료 도메인과 같이 높은 위험을 가진 다운스트림 작업에 특히 중요할 수 있습니다. 그러나 단점은 이러한 특징 추출기를 만드는 것이 지루한 프로세스이며 상당한 시간과 도메인 전문 지식이 필요할 수 있으며 이것이 항상 사용 가능한 것은 아니라는 것입니다.

### 2.3 Modern CV and Learned Representations

현대 컴퓨터 비전 방법($\approx$ 2012-현재)은 Figure 8에 시각화된 대로 수동으로 추출된 특징을 **learned intermediate representations(학습된 중간 표현)**로 대체합니다. 이 목적을 위한 가장 일반적인 모델 아키텍처 중 하나는 이미지에 적용되는 컨볼루션 필터 레이어로 구성된 **Convolutional Neural Networks(CNN, 컨볼루션 신경망)**입니다. 이러한 필터는 일반적으로 레이블이 지정된 훈련 데이터를 사용하여 학습되며 입력 데이터의 학습된 중간 표현을 제공합니다. 학습된 표현은 후속 분류기에 필수 정보를 제공하는 데 이전에 수작업으로 설계된 특징보다 훨씬 더 강력한 것으로 판명되었습니다.

학습된 표현은 이미지 분류와 같은 다운스트림 작업에서 더 높은 정확도를 보여주지만, 단점은 고전적인 표현의 해석 가능성이 부족하다는 것입니다. 학습된 표현을 해석하여 왜 그렇게 잘 수행하는지 그리고 어떻게 개선할 수 있는지 이해하려는 여러 방법이 있습니다. Zeiler와 Fergus [7]은 ImageNet에서 훈련된 CNN의 각 레이어에서 필터를 가장 강하게 활성화하는 특정 이미지 패치를 분석했습니다. 그들이 발견한 것은 Figure 9에 표시된 학습된 표현이 Figure 7에 표시된 전통적으로 추출된 특징(가장자리, 텍스처, 신체 부위)과 유사하다는 것이었습니다.

입력 데이터의 학습된 중간 표현을 이해하는 또 다른 접근 방식은 더 낮은 차원 공간으로 투영하여 플롯하고 해석할 수 있게 하는 것입니다. 이를 달성하는 한 가지 인기 있는 기법은 **tSNE** [5]입니다. 이것은 낮은 차원 임베딩과 원래 고차원 표현 사이의 결합 확률(데이터 유사성 기반)의 KL 발산을 최소화하여 고차원 중간 표현에 차원 축소를 수행합니다. 우리는 동일한 클래스의 데이터 점이 Figure 10에 시각화된 대로 지리적으로 서로 가까이 클러스터링될 것으로 예상합니다. 우리는 신경망이 실제로 동일한 레이블을 가진 이미지가 시각적으로도 유사하다는 것을 학습한다는 것을 확인하기 위해 tSNE를 사용할 수 있습니다.

### 2.4 Unsupervised and Self-Supervised Learning

전통적인 지도 학습 공식에서, 우리는 $D$ 데이터 포인트의 훈련 데이터셋 $\{(x_i, y_i)\}^D$에서 손실 함수(예: 이미지 분류 정확도 또는 포즈 추정)를 최소화하도록 특정 추론 작업에 대한 모델을 훈련시킬 수 있습니다. 여기서 $x_i$는 주어진 입력 표현(예: 이미지 또는 3D 포인트 클라우드)의 $i$번째 데이터 포인트이고 $y_i$는 출력 표현(예: 객체 카테고리 또는 6D 포즈)의 레이블입니다. 실제로 데이터는 풍부합니다. 그러나 레이블은 획득하기 비싸며 전문 지식이 필요할 수 있습니다. 레이블 없이 데이터로부터 의미 있는 표현을 학습할 수 있을까요? Figure 11의 **autoencoder(자동 인코더)** 아키텍처를 고려하세요. 자동 인코더의 목표는 입력 이미지를 완벽하게 재구성하는 것을 학습하는 것입니다. 이러한 인코더가 이를 얼마나 잘 달성할 수 있는지는 **reconstruction loss(재구성 손실)**로 측정되며, 이것은 동일한 표현에서 입력 데이터 $X$와 출력 $F(X)$ 사이의 차이로 정의됩니다. 여기서 입력 데이터의 중간 표현 $z$는 저차원 벡터이며 Figure 11의 네트워크 중간에 위치합니다. 직관적으로, 네트워크 $F$의 두 번째 절반이 $z$로부터 입력을 재구성할 수 있다면, $z$는 입력 데이터의 유용하고 정보가 있는 압축 버전입니다. 이러한 이유로 $z$를 **bottleneck(병목)**이라고 합니다.

자동 인코더는 입력 이미지(자체가 레이블로 볼 수 있음) 외에 외부 레이블이 필요하지 않기 때문에 **unsupervised learning(비지도 학습)**을 수행한다고 말합니다. 유사한 맥락에서, **self-supervised learning(자기 지도 학습)**은 입력의 일부를 마스킹하여 출력 레이블로 사용합니다. 예를 들어, Figure 12에 표시된 대로, 이미지 대각선 아래의 모든 픽셀을 입력으로 유지하고 대각선 위의 모든 픽셀을 출력으로 사용할 수 있습니다. 하단 부분이 주어지면, 작업은 이미지의 상단 부분을 재구성하는 것입니다. 희망은 네트워크가 이 작업을 달성하기 위해 입력 이미지에 대한 의미 있는 표현을 여전히 학습할 것이라는 것입니다. 이것은 다음 방식으로 어느 정도 경험적으로 입증되었습니다. 대량의 레이블이 없는 데이터에서 훈련된 자동 인코더가 주어지면, 네트워크의 첫 번째 절반(또한 **encoder(인코더)**라고도 함)으로 압축된 중간 표현 $z$를 얻을 수 있습니다. 그런 다음 소량의 레이블이 지정된 데이터만으로 중간 표현 $z$ 위에 분류기를 훈련시켜 출력 표현을 정확하게 예측할 수 있습니다. 왜냐하면 자동 인코더가 이미 입력에 대한 의미 있는 표현을 학습하는 무거운 작업을 수행했기 때문입니다.

---

## 참고 자료

- [Stanford CS231A Course Notes](https://web.stanford.edu/class/cs231a/course_notes.html)
- [07-representation-learning.pdf](https://web.stanford.edu/class/cs231a/course_notes/07-representation-learning.pdf)
